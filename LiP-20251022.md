Abbiamo detto che il nostro linguaggio ha:
$$ t = c\ |\ x\ |\ op_n(t_1,…,t_n)\ |\ if(t_0,t_1,t_2)\ |\ fun(z,t)\ |\ apply(t_1,t_2)\ |\ let\ x <= t_1\ in\ t_2$$
Poi abbiamo detto che c'è un ambiente $∂: Var\ ->\ Valore$, non si legge nulla. Big step, scope statico e scope dinamico. Non abbiamo formalizzato, e la formalizzeremo ora, la nozione di *blocco*. Un blocco è una qualche parte di programma che è in qualche modo segnalata, definita, in cui io c'ho un segnale di entrata e uno di uscita. Qui non abbiamo qualcosa di così specifico, i blocchi sono definiti dal $let$, quando solitamente lo renderemmo con $\{\}$.

Però, ora come ora, questo è raccontato solo. Noi avevamo fatto:

```
let y = 1 in
			 let f = fun(x, x+y) in
									let y = 2 in
												 apply(f, 1);;
```

E lì insomma sì abbiamo fatto la cosa d'inferenza in cui quel valore 1 rimpiazza y come valore da lì in poi.

...

Quando noi diamo la semantica operazionale small-step, uhhhh, torniamo a quelle booleane: costante true, costante else, if/else. Arriviamo a termini irriducibili, che sono costanti e funzioni. Le regole *nascondono molte cose*, che noi dobbiamo tenere a mente che esistono, e sono proprio le cose nascoste che ci permettono di usare un linguaggio, per esempio: quando uso un let, uso un nuovo ambiente ma quello vecchio non lo butto via.

```
let x = 1 in apply (Piu, (let y = 2 in x+y, let x = 2 in x));;
```

Che cosa succede? Succede che quando io vado a fare la valutazione di questa espressione, quando valuto `x+y`, lo faccio in un ambiente in cui `y=2` e `x=1`. Però, applicando la funzione `Piu`, uso $3$ come valore di `x+y`, ma uso $2$ come valore di `x`, a destra, perché valutando il secondo operando sono in un altro ambiente. Uscito da quel blocco però, riprendo il vecchio ambiente.