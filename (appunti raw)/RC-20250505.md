Inizia la terza parte, obbligatoriamente all'orale, quindi è molto più difficile, va saputa bene.
Come funzionano il livello rete e il livello internet. La parte della logica di TCPIP non la vediamo, perché è tutta applicazione. Potremmo vedere sessione e presentazione, ma non sarebbe molto utile.

Vediamo anche gli argomenti e le indicazioni per il secondo preappello.

Questo professore parla a voce *molto* bassa.

# Terza parte

Le slide governano la nostra preparazione !!!
Gli schemi, prendili sempre dalle slide, il libro di Tanenbaum è molto americano.

La prima parte è separata dal protocollo internet. La seconda e la terza invece sono collegate al protocollo specifico.

Un router (ipv) può collegare un host, una lan, o una batteria di lan.
Ci sono servizi orientati alla connessione e servizi connectionless. Connectionless -> path diversi.

Principio di banalità. Sono cose molto semplici e le devi sapere a memoria. Se non le sai, male.
I principi di commutazione stanno alla base del \[...\]. Sono tre, ma in realtà due sono lo stesso e l'altro è diviso in tre, quindi son quattro? Vedi slide per i nomi.

alfa e beta sono host paritetici. ABCDEF sono router. alfa chiede di connettersi a beta.
Il principio di esclusività del circuito: quando alfa si collega a beta, tutta la risorsa è a disposizione di quel collegamento finché non termina. Completamente diverso da TCPIP, questo è il più costoso possibile.

Nel grafico che sembra una ghigliottina nella slide 4, la singola lama rappresenta quanto ci mette una richiesta per andare da un router a un altro. Operazione d'ingaggio. La distanza verticale tra una lama e l'altra è quanto ci mette un nodo per elaborare la richiesta. Il segnale di accettazione è orizzontale e continuo, perché? Boh mi sono distratto.

Quando mi conviene la commutazione a circuito? È molto veloce, è una rete quasi esclusiva a me, la comunicazione è quasi istantanea. Quando non conviene? Se devo mandare pochissimi dati una volta ogni tanto, pessimo. È come affittare un'autostrada per far passare una bici una volta.

Oh, comunque, adesso parliamo di **messaggi**. Un messaggio è più di un pacchetto.

Occupo le linee solo quando mando un dato. E insieme al dato quindi mando anche un'intestazione.

Ricordati lo schema a 6 nodi che vedi nelle slide.

Questo messaggio si disciplina da solo. Quando arriva al router, gli dice che strada deve fare.

Parte da alfa, arriva alla sottorete di comunicazione, al nodo A. A legge l'intestazione, vede che deve arrivare a beta, per arrivarci può scegliere diverse strade, e qui entra in gioco il tempo di elaborazione al nodo. Il nodo ha anche una memoria di massa, e si salva il messaggio, così se a un certo punto si corrompe, non deve ripartire da alfa, ma magari riparte da metà strada. Lo cancella solo quando arriva un Acknowledgement dal nodo successivo. Quindi il vantaggio è di non occupare tutto il circuito sprecandolo, ma mi serve un sacco di memoria di massa.

Per ovviare al rischio di corruzione, creiamo la commutazione a pacchetto. Separiamo il messaggio in pacchetti (di circa 1500B di solito). E questo modello si presta sia al datagramma che al circuito virtuale.

Il datagramma, anche lì c'è l'intestazione, perché ciascun pacchetto è autonomo, ognuno fa una strada diversa. Svantaggi: no certezza sequenza arrivo. Ah tra l'altro, può capitare che un pacchetto finisca in un loop infinito, e poi il mittente lo rînvii e così ce ne sono due, e così via. Ma è una commutazione molto utile. E poi se un loop satura una sottosottorete, passa a un'altra sottosottorete per i prossimi.

Il circuito virtuale invece. Non c'è rilascio della connessione. Nel \[???\], dovevo prenderla tutta io se volevo usarla. Qui no, io passo, tu passi, easy. Il problema però, è che se ho deciso un path, una tratta, da alfa a beta, uso solo quella, e se più tardi quella tratta diventa più lenta e un'altra più veloce, mi tengo quella lenta. Utilizzato nel TCP.

### Algoritmi di routing

Due categorie. Statici e dinamici. Statici li progetto, e una volta accesa la rete restano così. In una rete dinamica, le tratte cambiano dinamicamente, in base al traffico (occupazione).

Vedi le slide.

10\. Se io attraverso un cammino ottimo, ogni sottocammino è anch'esso ottimo (?). Principio dell'ottimalità.

Load balancing: mando un pacchetto su una tratta e uno su un'altra, così se cade una tratta ho l'altra, e vengono ordinati alla fine.

Tempo di convergenza: minore è, più è utilizzata la rete.

Shortest path routing: sembra Dijkstra. Che succede se si rompe una tratta?

Flooding: anziché spaccarti la testa a calcolare il percorso ottimale, manda dappertutto, prima o poi arriva tutto. Ogni pacchetto ha una quantità massima di hop, dopo quella si arrende. Non riattraversa nodi già attraversati, se ci prova viene eliminato. Prova ad andare nella direzione giusta, quindi a non tornare indietro.

Distance vector: ma anche questa è roba di ASD.

Paradosso del conteggio all'infinito. Non ho capito. Comunque non è un granché, quindi si usa un link state packet invece.

Si può presumere che l'invio del pacchetto HELLO sia fatto una volta. Poi si fa una batteria di invii del pacchetto ECHO. Così ho una lista di nodi, e la loro velocità. E comincio a fare una lista di nodi+percorsi+costo.

Vedi spanning tree. Te le fa disegnare all'orale.
Credo sia tipo il grafo ma ottimizzato.

Incapsuliamo cose da un protocollo per farle passare attraverso un altro protocollo.

Controllo di congestione (somiglia al thrashing). C'è controllo chiuso e controllo aperto.

Choke packet: se c'è un host che mi sta congestionando una porta, gli invio un choke packet quando arriviamo alla soglia di pericolo. "Stai zitto due secondi please". Magari ci vuole troppo, tempo che gli arrivi lui mi ha già affogato. Hop by hop: lo mando al nodo precedente e rallento lui, e poi lui sarà troppo lento e rallenta quello prima, e così via.

Drop tail: se non ce la fai ignoralo. Capirà da solo che se non mandi più ack, magari è troppo veloce.

Load sharing: c'è variante vino e variante latte, cioè mantieni i pacchetti vecchi o i pacchetti nuovi.

Specifica funzione, su cui viene calcolato il peso sulla base di due array, marcature, media, non sento, lo chiede all'orale.

Quality of service, concetto fondamentale. Valore che riesco a dare all'affidabilità di una rete, perché il servizio è la mia rete.