# Programmazione Funzionale

Week 9

## Recap della lezione precedente (ci ha messo solo 1/3 della lezione)

Nei lnpr recenti si preferisce avere più paradigmi insieme pk alcune cose k vgliamo fare sono astratte (vedi i livelli di astrazione) più comodamente da certi paradigmi.
Più astraiamo, più è comodo parlare di certe cose, ma più la comodità del paradigma è specializzata.
Quindi un lnpr k h + d 1 paradigma ci dà la pssblt' di xr + liberi di fr' ql k vglm.

Nl prgrmzn fnznl- possiamo fr- fnzn' anonime (senza nome) e passarle come variabili.

Abbiamo visto nk 1 po' di prgrmzn logica (assiomi senza una vera e propria semantica), in Prolog, k inaspettatamt- è turing-compatibile.

Un altro prdgm, + recente, è il quantum computing, in un certo senso. Una macchina fisica molto diversa da quelkle a cui siamo abituati, che sfrutta quanti e caratteristiche fisiche subatomiche che neanche capiamo noi in realtà, ma insomma per gli stessi problemi si hanno approcci, algoritmi e complessità potenzialmente completamente diversi.

Noi però ci siamo concentrati sul prdgm fnznl, k hbm già vst con ocaml. Java è stato pensato a oggetti, e quindi fa bene quello, invece ocaml è nato per essere funzionale, soprattutto il suo predecessore caml.
Quindi in Java è stato inventato un modo per programmare pezzi di codice funzionale in mezzo al codice a oggetti.
In paradigma funzionale, le funzioni NON HANNO SIDE EFFECT, è solo input output, operando risultato. Funzioni deterministiche, gli stessi input danno sempre gli stessi output (no random, no file). I dati sono immutabili.

Rivedi le HOF.

Quindi da Java 8 in poi, si può programmare funzionalmente tramite le Java Lambda.
Superficialmente creiamo funzioni. In realtà sotto sotto stiamo creando oggetti. Così come possiamo creare un oggetto creando una classe usa e getta nella dichiarazione dell'oggetto (classi anonime), possiamo anche creare un oggetto la cui classe ha solo un metodo e nient'altro, una funzione anonima.

Questo è un oggetto anonimo di classe anonima:

```
new Comparator<String>() {
	@Override
	public int compare(String a, String b) {
		return a.substring(1).compareTo(b.substring(1));
	}
}
```

E questo è equivalente ma con le Java Lambda:

```
(String a, String b) -> {return a.substring(i).compareTo(b.substring(i))};
```
E questo è un singolo metodo, che ha molto in comune con una funzione. Non è *davvero davvero* una funzione, è un metodo, ma in un certo senso è davvero una funzione. Stiamo implementando un'interfaccia definendo l'unico metodo che dichiara. L'interfaccia non può che essere `Comparator` se stiamo passando questo oggetto a `Collections.sort`.

Comunque sì, bello che sia solamente una riga di codice. Ma ti rendi conto? Creo un'intera classe e un oggetto di quella classe, tutto in una riga, in modo leggibilissimo. E poi faccio finta che sia semplicemente una funzione. Splendido. Sembra quasi un sottolinguaggio dentro Java per quando non ti basta Java (capita spesso che non ti basti Java).

Python sarà anche più stringato, senza specificare i tipi statici di tutte le variabili e le classi degli oggetti, e avrà anche una sintassi più compatta e meno verbosa, **ma le funzioni lambda sono più compatte e leggibili in Java**. Anche perché le lambda di Java rimane il controllo di tutti i tipi statici, è per quello che il compilatore capisce che stai implementando `Comparator` se la stai passando a `Collections.sort`.

E tra l'altro, anche su Python, sono stati fatti degli strumenti che *tramite commenti* introducono il controllo dei tipi dei parametri. Ma non ti garantisce niente. Guarda cosa deve fare per imitare una frazione del potere di Java.

Nelle lambda, magari capisce anche la classe dei parametri.
	`a -> a.substring(1)` – è ovvio che `a` sia una `String`.
	
## Comincia la lezione di oggi !!! !!! ! !! ! !

Con l'argomento dopo questo, useremo insieme le collections e le lambda. Quindi dobbiamo vedere i *method references*.

### Method references

Le lambda expressions cnsntn di dfnr- fnzn'. Magari però la funzione che vogliamo "passare" è già definita. Come facciamo a trattarla come una lambda function?

Usiamo un esempio. Funzione pura che prende in input una stringa e rende in output la stessa stringa ma in minuscolo. Pensiamola contemporaneamente come funzione pura e come metodo. Anzitutto una funzione pura deve corrispondere a un metodo static, perché l'output deve dipendere sempre dai parametri. Però può comunque usare metodi non statici nella sua definizione.

Come metodo:
```
public static String minuscolo (String s) {
	return s.toLowerCase();
}
```

Come funzione lambda semplice:
```
(String s) -> {return s.toLowerCase();}
```

Come funzione lambda stringata:
```
s -> s.toLowerCase()
```

Però... Però. Non sto facendo niente di mio, sto solo applicando `.toLowerCase()`, che esiste già. In Java, in questi casi si usano le *method references*.

Ricordiamo che le lambda le possiamo scrivere solo quando c'è un'interfaccia funzionale, in contesti dove ci serve un metodo, quando è scontato che `s` sia una stringa.

A dire il vero possiamo assegnare le lambda come valori a oggetti di tipo `Function<T,R>`.

```
Function<String, String> f1 = s -> s.toLowerCase();
```

Ha due tipi parametrici: quello dell'input e quello dell'output. La funzione lambda diventa il metodo `R apply(T)` della classe. Quindi per applicarla si fa, per esempio, `f1.apply(a)`.

Questo era `Function`. In realtà nello stesso package c'è anche `BiFunction<T,U,R>`. Ha tre tipi: prende due input e rende un output.

Ah tra l'altro finalmente torniamo a noi. È passata un'altra mezz'ora. **method references!***

```
Function<String,String> f1 = String::toLowerCase;
```

Sì tutto qui.

No, non tutto qui! Scusa ma, `.toLowerCase` è un metodo da `String` a `String`? Beh rende `String` in output, ma mica ha parametri in input! Beh Java è intelligente, quindi interpreta, nelle funzioni non statiche, l'oggetto stesso come parametro.

Ci sono quattro casi per le method references. Usano tutti `::`. Riferimenti a metodi statici, metodi d'istanza dato un oggetto, metodi d'istanza data la classe, e metodi costruttori. `Classe::metodo`, `Oggetto::metodo`, `Classe::metodo`, `Classe::new`.

Figo:
```
BiFunction<String,String,Integer> f2 = (s1,s2) -> 5;
Comparator<String> f1 = f2::apply
```
Si fa così.