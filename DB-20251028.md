# Hashing

Hai le chiavi `key`, hai una funzione `h()` che data una chiave ne restituisce l'hash. Hai un indice hash in cui all'indice `h(key)`si trova un puntatore al punto in cui è memorizzato il dato con indice `key`.

Le operazioni che si svolgono sono:
* Calcolare h(key), con costo 0 perché non leggo nessun blocco
* Lettura blocco indice hash, costo 1 perché so già dove lo trovo, non devo neanche cercarlo
* Seguo il puntatore e arrivo al dato, lettura blocco record cercato, costo 1 perché appunto so già dove lo trovo grazie al puntatore
Il costo totale è 2, come nel caso di un B-Tree talmente piccolo che è solo la radice. Quindi sì, l'hashing ha un costo molto basso.

Quando è grande un blocco? Di solito 4 kB.

Le #slide sono simpatiche. Quando fai l'hashing, di solito ci sono molte più chiavi possibili che hash, ed è voluto (come detto in ASD e in PR2). Un hash quindi può avere più puntatori (collisione, clash), come facciamo? Beh allochiamo, nell'indice hash, un blocco per possibile valore dell'hash. 4kB bastano per molti puntatori.

Una buona funzione hash deve distribuire bene le chiavi tra i possibili hash.

## Hashing dinamico

Quando io alloco lo spazio per il mio indice hash, alloco lo stesso spazio per ogni hash. Vedi dalle slide, figata.