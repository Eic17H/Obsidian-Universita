Abbiamo visto un linguaggio funzionale. Abbiamo visto sia la semantica small-step che big-step, abbiamo ciò che possiamo considerare funzioni higher-order: possiamo passare funzioni ad altre funzioni e farci operazioni. Queste cose in certi linguaggi sono naturali, in altri linguaggi non lo sono.

Però esiste l'altro modo, che conosciamo meglio, per scrivere programmi, cioè il paradigma imperativo: l'esecuzione di un programma è determinata da come questo programma è scritto proprio fisicamente. Quindi ci immaginiamo l'algoritmo che risolve il nostro problema, troviamo le strutture dati adatte, esprimiamo l'algoritmo come una sequenza di istruzioni, ed eseguiamo il programma tenendo conto che le istruzioni funzionano come la macchina di Von Neumann, e le istruzioni sono memorizzate e sappiamo qual è la prossima perché, in una macchina fisica, ce lo dice il program counter. Noi non abbiamo il program counter, ma useremo altri metodi.

Come lo scriviamo il fattoriale? In OcaML, che è funzionale:

```
let rec fact z = if x = 0 then 1 else fatt (x-1) * x;;
```

Nel nostro linguaggio, diciamo di avere scopo dinamico:

```
let fact <= fun(x, if(x=0, 1, x*apply(fact, x-1))) in ...
```

Secondo il teorema di ???, qualunque cosa che si può fare ricorsivamente si può fare anche iterativamente. E allora facciamolo.

```
x := n;
y := 1;
while (x > 0) do
	y := y*x;
	x := x-1;
```

Seguiamo i passaggi:

```
(x,y)
3, 1
2, 3
1, 6
0, 6
```
Ed effettivamente 3!=6.

Abbiamo eseguito un'istruzione dopo l'altra. L'unica eccezione è il `while`, che mi dice che certe istruzioni vanno ripetute. In origine, `:=` era l'operatore di assegnamento, in C è stato sostituito da `=`, ma si usa ancora in matematica.

Notiamo che al secondo ciclo, `x` e `y` non sono gli stessi `x` e `y` del primo ciclo. Il loro valore è stato modificato.

La seconda cosa che è seccante nei linguaggi imperativi e invece molto chiara nei linguaggi funzionali è: dove diavolo è il risultato? Un linguaggio funzionale definisce funzioni, quindi il risultato della funzione viene mostrato direttamente a video o usato come valore. Nel paradigma imperativo, stiamo imperando azioni, quindi devo dire io cosa fare con ciascun valore.

# Sintassi dei linguaggi imperativi

* $Var$: Variabili: $X$
* $ExprArit$: Espressioni aritmetiche: $a = n | piu(a_1,a_2)|per(a_1,a_2)|X|...$
* $ExprBool$: Espressioni booleane: $b=true|false|and(b_1,b_2)|or(b_1,b_2)|not(b)|eq(a_1,a_2)|less(a_1,a_2)$

Qui niente mi impedisce di dare la semantica big-step (quella con le inferenze), e qui dovremo introdurre lo <span class="pink"><i>stato</i></span>. Non è l'ambiente, è lo <span class="pink"><i>stato</i></span>.

Ricordiamo da MD che possiamo rappresentare i numeri relativi come coppie il cui valore è la differenza tra il primo e il secondo numero, così possiamo rappresentare i numeri negativi derivandoli dai positivi; avendo più modi di rappresentare ciascun numero dovrò definire un modo per arrivare alla forma canonica. Da FDI e da ARE ricordiamo invece i numeri in complemento a 2. Qui invece il problema è che dobbiamo valutare un'espressione aritmetica in un certo stato.

Quindi per i numeri, che sono costantti, $<n,st>->n$, invece per le vriabili $<x,st>->st(x)$. E me ne vado, leggerò il libro.