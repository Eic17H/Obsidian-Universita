Abbiamo il nostro linguaggio operativo IMP, in cui
$$
	c ::= skip\ |\ X:=a\ |\ c1;c2\ |\ if\ b\ then\ c_1\ else\ c_2\ |\ while\ b\ do\ c
$$
Abbiamo lo stato $st:=Var→Z$, e $Sigma = {st|st:Var→Z}$

Big step: Com x (simbolo strano ς) → ς

Small step: Com x Sigma → (Com x ς) U Sigma

Con le regole di inferenza: \[<c1;c2,st>→<c2,st'> | <c1,st>→st'\], altra regola \[<c1;c2,st>→<c1';c2,st'> | <c1,st>→<c1',st'>\]

Def: un comando termina se $<c,st>→*st'$.

Teorema: <c,st>-(bs)→st' e c termina, allora <c,st>-(bs)→\*st'. Se c termina allora se <c,st>-(ss)→\*st' vale che <c,st>-(bs)→st'. Boh.

La semantica small step mi definisce un sistema di riscrittura, quella big step invece mi dice come costruire l'albero di derivazione: non sto riscrivendo, sto mettendo assieme tutte quante le cose che sono nell'applicazione delle regole che mi servono per costruire un albero di derivazione, un albero le cui foglie sono assiomi e la cui radice è...

# Nuova lezione

Aggiungiamo le dichiarazioni e i blocchi. Aggiungiamo un'altra cosa alla semantica.

$$
	c ::= skip\ |\ X:=a\ |\ c1;c2\ |\ if\ b\ then\ c_1\ else\ c_2\ |\ while\ b\ do\ c\ |\ begin\ d;c\ end
$$
Prima io avevo il mio $st:Var→Z$. Definiamo adesso una dichiarazione.

$$
d::=null\ |\ var\ X=a\ |\ d_1,d_2
$$
Mi conviene avere null, abbiamo la dichiarazione di una variabile, e possiamo avere due dichiarazioni di fila.

Con l'uguale, non stiamo facendo un assegnamento, stiamo assegnando a un nome un certo valore, che per semplicità immaginiamo sia un numero. Un esempio di blocco:

```
{
	var X = 3;
	var Y = 1;
	while X > 1 do {
		Y = Y * X;
		X := X - 1;
	}
}
```

Non c'è differenza tra big step e small step. \[<null,st>→\_d st | ], \[\<var X=n,st>→\_d st\[X/n\]\ | ], \[<d1;d2,st>→\_d st | <s1,st>→_d st1    <d2, st1>→_d st'>]. Lo stato diventa una coppia che ha ambiente e la memoria, che il bohhh.

"Dobbiamo dividere lo stato già da ora, perché altrimenti, vi faccio vedere il motivo".

```
{
	var X = 3;
	{
		var X = 2;
		X := X+3;
	}
	X := X+1;
}
```
Quanto vale X alla fine? Con la semantica definita finora, io questo non lo posso fare.

Adesso diciamo che lo stato è una coppia (delta, sigma). diciamo che delta: Var→Locazioni (l-value), e sigma: Locazioni→Z (numeri).

Allora <null,(delta,sigma)>→(delta,sigma)|, <varX=n,(delta,sigma)>→(delta\[X/l\],sigma\[l/n\])|l=newloc(). La terza è enorme non ci provo neanche

C: Com x Env x Store. Comando, ambiente, memoria. Cosa può essere un comando? Va troppo veloce e non finisce le frasi. E anche questo si studia dal libro. Minchia più va avanti meno frasi finisce.

Nel mio blocco C1 creo un'associazione dal nome X alla locazione 5A. Nel blocco C2, interno al blocco C1, associo al nome X la locazione 2C. Il valore di 5A esiste ancora in memoria, ma non è accessibile al blocco C2 perché non ho nessun nome associato a quella locazione. Ci è voluto un po' per decifrare cosa stesse dicendo.

Sostanzialmente sì stiamo prendendo una funzione e restituendone una simile, questa funzione associa nomi a locazioni e così questo sostanzialmente ci permette di, sostanzialmente.